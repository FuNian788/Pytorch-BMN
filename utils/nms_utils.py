import torch
import numpy as np
import pandas as pd

from utils.iou_utils import iou_with_temporal_proposals

def soft_nms_proposal(df_proposal, alpha, t1, t2, num_return_proposal):
    """
    Soft Non-Max-Suppression on temporal proposals in inference process. Used in video field.
        Soft NMS will suppress the score of low-score proposals which has high IoU with high-score proposals.

    Arguements:  
        df_proposal (pandas.DataFrame): a csv file which contains start/end/score of proposals generated by network.
        alpha (float[1]): alpha value for Gaussian decaying function.
        t1 (float[1]): lower threshold for soft NMS.
        t2 (float[1]): higher threshold for soft NMS.
        num_return_proposal (int[1]): number of max return proposals.

    Return Arguements:    
        return_df (pandas.DataFrame()): remaining bounding boxes after NMS, which concludes 'start', 'end' and 'score'.
    """
    proposal_information = df_proposal.sort_values(by='score', ascending=False)

    # len(t_start) == len(t_end) == num_proposals
    # Directly concate corresponding element of 't_start' and 't_end' to get initial proposals.
    t_start = list(proposal_information.start.values[:])
    t_end = list(proposal_information.end.values[:])
    score = list(proposal_information.score.values[:])

    t_start_return = []
    t_end_return = []
    score_return = []

    while len(score) > 1 and len(score_return) < num_return_proposal:
        max_index = score.index(max(score))
        ious = iou_with_temporal_proposals(np.array(t_start), np.array(t_end), t_start[max_index], t_end[max_index])
        for i in range(len(score)):
            if i != max_index:
                iou = ious[i]
                length = t_end[max_index] - t_start[max_index]
                # if iou(max_score_bbox, b_i) is above the threshold, then `score_i = score_i * function(iou(max_score_box, b_i))`.
                # Here we use Gaussian kernel as the function.
                if iou > t1 + (t2 - t1) * length:
                    score[i] = score[i] * np.exp(-np.square(iou) / alpha)
        
        t_start_return.append(t_start[max_index])
        t_end_return.append(t_end[max_index])
        score_return.append(score[max_index])

        t_start.pop(max_index)
        t_end.pop(max_index)
        score.pop(max_index)

    return_df = pd.DataFrame()
    return_df['start'] = t_start_return
    return_df['end'] = t_end_return
    return_df['score'] = score_return

    return return_df



